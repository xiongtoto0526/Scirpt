{"version":3,"sources":["/source/util/lib/util/get-injectable-name.ts"],"names":[],"mappings":";;;;;;uBAA8B,YAAY;;oCAIf,0BAA0B;;kCACzB,yBAAyB;;AAErD,IAAa,iBAAiB,GAAG,SAApB,iBAAiB,CAAI,UAAe,EAAA;AAE/C,QAAG,OAAO,UAAU,KAAK,QAAQ,IAAI,UAAU,2CAAuB,EAAE;AACtE,eAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;KAC9B,MAGI,IAAG,uBAAc,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE;AAC7C,eAAO,uBAAc,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;KAC9C;CACF,CAAC;;AAEF,IAAa,gCAAgC,GAAG,SAAnC,gCAAgC,CAAI,UAAe,EAAA;AAC9D,QAAI,IAAI,GAAG,iBAAiB,CAAC,UAAU,CAAC,CAAC;AAEzC,QAAI,IAAI,EAAE;AACR,eAAO,IAAI,CAAC;KACb;AAID,QAAI,OAAO,UAAU,KAAK,UAAU,EAAE;AACpC,8CAAW,UAAU,CAAC,CAAC;AACvB,eAAO,uBAAc,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;KAC9C;CACF,CAAC","file":"util/get-injectable-name.js","sourcesContent":["import { providerStore } from '../writers';\n// ## Intro\n// Import the `@Injectable` decorator. We'll apply it to functions/classes that are\n// injected that are missing provider metadata. Convenience!\nimport { Injectable } from '../decorators/injectable';\nimport { OpaqueToken } from '../classes/opaque-token';\n\nexport const getInjectableName = (injectable: any) => {\n  // Return it if it is already a string like `'$http'` or `'$state'`\n  if(typeof injectable === 'string' || injectable instanceof OpaqueToken) {\n    return injectable.toString();\n  }\n  // If the injectable is not a string but has provider information, use\n  // the provider name. This is set by the collection of provider decorators\n  else if(providerStore.has('type', injectable)) {\n    return providerStore.get('name', injectable);\n  }\n};\n\nexport const getInjectableNameWithJitCreation = (injectable: any) => {\n  let name = getInjectableName(injectable);\n\n  if (name) {\n    return name;\n  }\n\n  // If it is a function but is missing provider information, apply the Injectable\n  // provider decorator to the function to turn it into a service.\n  if (typeof injectable === 'function') {\n    Injectable(injectable);\n    return providerStore.get('name', injectable);\n  }\n};"],"sourceRoot":"/source/"}
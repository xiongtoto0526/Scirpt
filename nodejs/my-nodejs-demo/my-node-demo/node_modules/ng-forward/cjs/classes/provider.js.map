{"version":3,"sources":["/source/classes/lib/classes/provider.ts"],"names":["Provider","Provider.constructor","Provider.type","Provider.dependencies"],"mappings":"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","file":"classes/provider.js","sourcesContent":["import { bundleStore, providerStore } from '../writers';\nimport Module from './module';\nimport {Inject} from '../decorators/inject';\nimport {getInjectableNameWithJitCreation} from '../util/get-injectable-name';\nimport {Providers} from '../decorators/providers';\nimport {INJECTABLE} from '../decorators/injectable';\nimport {OpaqueToken} from \"./opaque-token\";\n\nconst TYPE = 'provider';\n\n/**\n * A binding from a token to a value (only one implemented currently), class, existing, or factory\n */\nexport class Provider {\n  public token: any;\n  public useClass: any;\n  public useValue: any;\n  public useConstant: any;\n  public useFactory: any;\n  private _dependencies: string[] = [];\n  private _type: string;\n\n  constructor(token: string|OpaqueToken|Function,\n    {\n      useClass,\n      useValue, \n      useConstant, \n      useFactory, \n      deps\n    } : \n    { \n      useClass?: any, \n      useValue?: any, \n      useConstant?: any, \n      useFactory?: any, \n      deps?: any[]\n    }\n  ) {\n    try { this.token = getInjectableNameWithJitCreation(token); }\n    catch (e) { throw new Error(`new Provider() Error: Invalid token ${token}`); }\n\n    Object.assign(this, {useClass, useValue, useConstant, useFactory});\n\n    if (!useClass && !useValue && !useConstant && !useFactory) {\n      throw new Error(`new Provider(${token}) Error: No usage provided (i.e. useClass, useValue, useConstant, useFactory)`)\n    }\n\n    if (deps) {\n      // Simulate having both an @Inject and provide: [] on the factory function\n      Inject(...deps)(this.useFactory);\n      Providers(...deps.filter(d => typeof d !== 'string'))(this.useFactory, `while analyzing Provider '${this.token}' useFactory deps`);\n      this._dependencies = bundleStore.get('$inject', this.useFactory);\n    }\n\n    // Setup provider information using the parsed selector\n    providerStore.set('name', this.token, this);\n    providerStore.set('type', TYPE, this);\n  }\n\n  get type(): string {\n    if (this._type) return this._type;\n    \n    this._type = Object.keys(this).find((k: string) : boolean => k.startsWith('use') && this[k] !== undefined);\n    \n    return this._type;\n  }\n  \n  get dependencies(): string[]{\n    return this._dependencies;\n  }\n}\n\n\n// ## Provider Parser\nModule.addProvider(TYPE, (provider: Provider, name: string, injects: string[], ngModule: ng.IModule) => {\n  switch (provider.type) {\n    case 'useValue':\n        ngModule.value(provider.token, provider.useValue);\n        break;\n    case 'useConstant':\n        ngModule.constant(provider.token, provider.useConstant);\n        break;\n    case 'useClass':\n        injects = bundleStore.get('$inject', provider.useClass) || [];\n        Module.getParser(INJECTABLE)(provider.useClass, provider.token, injects, ngModule);\n        break;\n    case 'useFactory':\n        ngModule.factory(provider.token, [...provider.dependencies, provider.useFactory]);\n        break;\n    default:\n        break;\n  }\n});\n\n\n/**\n * Sugar for creating a new binding.\n * @param token\n */\nexport const provide = (token: string|OpaqueToken|Function,\n    {\n      useClass,\n      useValue, \n      useConstant, \n      useFactory, \n      deps\n    } : \n    { \n      useClass?: any, \n      useValue?: any, \n      useConstant?: any, \n      useFactory?: any, \n      deps?: any[]\n    }\n  ) : Provider => {\n  return new Provider(token, {useClass, useValue, useConstant, useFactory, deps});\n};"],"sourceRoot":"/source/"}
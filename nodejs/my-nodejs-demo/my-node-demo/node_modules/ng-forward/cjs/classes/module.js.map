{"version":3,"sources":["/source/classes/lib/classes/module.ts"],"names":["DecoratedModule","DecoratedModule.constructor","DecoratedModule.add","DecoratedModule.publish","DecoratedModule.moduleList","DecoratedModule.config","DecoratedModule.run","DecoratedModule.value","DecoratedModule.constant"],"mappings":"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","file":"classes/module.js","sourcesContent":["// # Module\n// A thin wrapper around `angular.module` for transforming annotated classes into\n// angular providers\n//\n// ## Setup\n// Unless you are using a shim, all official distributions of Angular.js install\n// `angular` on `window`. It is safe to assume it will always be there.\n/* global angular */\n// The core of the module system relies on special metadata writers. They write\n// namespaced metadata to a class. Each writer is responsible for handling some\n// subset of useful information\nimport {bundleStore, providerStore} from '../writers';\n\n// A very simple map holding the parsers for each provider. More on this later.\nlet _parsers: any = {};\n\n// ## DecoratedModule class\n// Define the Module wrapper class.\nexport class DecoratedModule{\n\tprivate _module: ng.IModule;\n\tprivate _dependencies: any[];\n\t\n\tconstructor(public name: string, modules: any = false){\n\t\t// `angular.module` works either by creating a new module via an array\n\t\t// of dependencies or by reference without the dependencies array\n\t\tif(modules)\n\t\t{\n\t\t\t// parse the module list to create an array of just strings\n\t\t\tthis.moduleList(modules);\n\t\t\t// Create the angular module.\n\t\t\tthis._module = angular.module(name, this._dependencies);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// If no dependencies were passed, access the module by reference\n\t\t\tthis._module = angular.module(name);\n\t\t}\n\t}\n\n\t// This is where you add an annotated class to the Angular module\n\tadd(...providers: any[]): DecoratedModule {\n\t\t// We used a rest parameter so that you can add multiple providers at once.\n\t\t// So we must iterate over our array of providers.\n\t\tfor(let provider of providers)\n\t\t{\n\t\t\t// The providerStore contains the type of provider the class will be transformed\n\t\t\t// into as well as the name of the eventual provider. If this information has\n\t\t\t// not been set on the class, then we aren't dealing with a decorated class.\n\t\t\tif( !providerStore.has('type', provider) ){\n\t\t\t\tthrow new Error(`Cannot read provider metadata. Are you adding a class that hasn't been decorated yet?`);\n\t\t\t}\n\n\t\t\t// Grab the type of provider\n\t\t\tlet type = providerStore.get('type', provider);\n\t\t\t// ...and the name of the provider\n\t\t\tlet name = providerStore.get('name', provider);\n\t\t\t// This is the injection array used by angular's `$injector.invoke`. This array\n\t\t\t// is just a list of strings that will be injected\n\t\t\tlet inject = bundleStore.get('$inject', provider) || [];\n\n\t\t\t// We use the provider type to determine which parser will handle the class\n\t\t\tif(_parsers[type]){\n\t\t\t\t// Execute the parser passing the class, name of the provider, injection\n\t\t\t\t// array, and the raw `angular.module` we defined in the constructor.\n\t\t\t\t_parsers[type](provider, name, inject, this._module);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthrow new Error(`No parser registered for type '${type}'`);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t// Dead code from angular-decorators that should probably be removed. Just returns\n\t// the raw angular.module.\n\tpublish(): ng.IModule{\n\t\treturn this._module;\n\t}\n\n\t// Parses the array of modules\n\tmoduleList(modules: any[]){\n\t\t// Setup the dependency array\n\t\tthis._dependencies = [];\n\n\t\tif(modules && modules.length !== 0){\n\t\t\t// Iterate over the modules. Would be better done via `modules.map`, but\n\t\t\t// it works.\n\t\t\tfor(let i = 0; i < modules.length; i++)\n\t\t\t{\n\t\t\t\t// If the module is a string (i.e. 'ui-router' or 'ngAria') then we are\n\t\t\t\t// already set\n\t\t\t\tif(typeof modules[i] === 'string')\n\t\t\t\t{\n\t\t\t\t\tthis._dependencies.push(modules[i]);\n\t\t\t\t}\n\t\t\t\t// If it isn't a string but has a name then use the name instead. Raw\n\t\t\t\t// `angular.module`s provide the name here as does our reimplementation.\n\t\t\t\telse if(modules[i] && modules[i].name)\n\t\t\t\t{\n\t\t\t\t\tthis._dependencies.push(modules[i].name);\n\t\t\t\t}\n\t\t\t\t// If neither case was met, throw an error\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new Error(`Cannot read module: Unknown module in ${this.name}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Alias over the raw config function\n\tconfig(configFunc: any): DecoratedModule{\n\t\tthis._module.config(configFunc);\n\n\t\treturn this;\n\t}\n\n\t// Alias over the raw run function\n\trun(runFunc: any): DecoratedModule{\n\t\tthis._module.run(runFunc);\n\n\t\treturn this;\n\t}\n\n\t// Alias for the value provider\n\tvalue(name: string, value: any): DecoratedModule{\n\t\tthis._module.value(name, value);\n\n\t\treturn this;\n\t}\n\n\t// Alias for the constant provider\n\tconstant(name: string, value: any): DecoratedModule{\n\t\tthis._module.constant(name, value);\n\n\t\treturn this;\n\t}\n}\n\n// Becuase I determined `export default new Module` to be too long, wrap the\n// `DecoratedModule` class in a simple factory function.\nlet Module: any = function(name: string, modules?: any): DecoratedModule{\n\treturn new DecoratedModule(name, modules);\n};\n\n// A static function for adding new parsers. You pass it a type like 'factory' and\n// a parsing function. This parsing function is what is called in the `DecoratedModule.add`\n// function\nModule.addProvider = function(providerType: string, parser: any){\n\t_parsers[providerType] = parser;\n};\n\n// Retrieve a parser. Only useful for tests and checking if a parser has already been\n// set\nModule.getParser = function(providerType: string): any{\n\treturn _parsers[providerType];\n};\n\n// ## Conclusion\n// Finally export module\nexport default Module;\n"],"sourceRoot":"/source/"}
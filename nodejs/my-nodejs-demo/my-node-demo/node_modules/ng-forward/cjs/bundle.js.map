{"version":3,"sources":["/source/lib/bundle.ts"],"names":["bundle","bundle.parseProvider"],"mappings":";;;;;;;qBAoBA,MAAA;;;;;;uBAf0B,WAAW;;6BAEC,kBAAkB;;;;4BAGrC,iBAAiB;;;;yCAGC,gCAAgC;;;;AAOrE,SAAA,MAAA,CAA+B,UAAkB,EAAE,QAAa,EAA4B;;;QAA1B,cAAc,yDAAU,EAAE;;AAE1FA,QAAMA,gBAAgBA,GAAGA,SAAnBA,gBAAgBA,CAAIA,CAAMA;eAAKA,qBAAYA,GAAGA,CAACA,WAAWA,EAAEA,CAACA,CAACA,IAAIA,EAAEA;KAAAA,CAACA;AAE3EA,QAAMA,cAAcA,GAAGA,SAAjBA,cAAcA,CAAIA,CAAMA;eAAKA,qBAAYA,GAAGA,CAACA,SAASA,EAAEA,CAACA,CAACA,IAAIA,EAAEA;KAAAA,CAACA;AAEvEA,QAAMA,uBAAuBA,GAAGA,SAA1BA,uBAAuBA,CAAIA,IAAcA,EAAEA,KAAUA;eAAKA,6BAAIA,IAAIA,GAAEA,MAAMA,CAACA,UAAAA,CAACA;mBAAIA,KAAKA,IAAIA,CAACA,CAACA,KAAKA,KAAKA,KAAKA;SAAAA,CAACA,CAACA,MAAMA,GAAGA,CAACA;KAAAA,CAACA;;oCAI9DA,6CAA0BA,QAAQA,4BAAKA,cAAcA,yCAClFA,UAAUA,eAAWA;;QADzCA,eAAeA,6BAAxBA,OAAOA;QAA8BA,iBAAiBA,6BAA5BA,SAASA;;AAOxCA,QAAIA,SAASA,GAAGA,IAAIA,GAAGA,EAAOA,CAACA;AAG/BA,QAAIA,OAAOA,GAAGA,IAAIA,GAAGA,CAAaA,eAAeA,CAACA,CAACA;AAInDA,aAAAA,aAAAA,CAAuBA,QAAaA,EAAAA;AAClCC,YAAIA,QAAQA,EAAEA;AAGZA,gBAAIA,SAASA,CAACA,GAAGA,CAACA,QAAQA,CAACA,IAAIA,uBAAuBA,CAACA,SAASA,EAAEA,QAAQA,CAACA,KAAKA,CAACA,EAAEA;AACjFA,uBAAOA;aACRA;AAGDA,qBAASA,CAACA,GAAGA,CAACA,QAAQA,CAACA,CAACA;AAGxBA,gBAAIA,SAASA,GAAGA,QAAQA,CAACA,QAAQA,IAAIA,QAAQA,CAACA,UAAUA,IAAIA,QAAQA,CAACA;AAErEA,0BAAcA,CAACA,SAASA,CAACA,CAACA,OAAOA,CAACA,UAACA,GAAQA;uBAAKA,OAAOA,CAACA,GAAGA,CAACA,GAAGA,CAACA;aAAAA,CAACA,CAACA;AAElEA,4BAAgBA,CAACA,SAASA,CAACA,CAACA,OAAOA,CAACA,aAAaA,CAACA,CAACA;SACpDA;KACFA;AAGDD,qBAAiBA,CAACA,OAAOA,CAACA,aAAaA,CAACA,CAACA;AAGzCA,WAAOA,WAAAA,gCAAOA,UAAUA,+BAAMA,OAAOA,GAAEA,EAACA,GAAGA,MAAAA,6BACtCA,0BAAOA,OAAOA,EAAEA,4BAChBA,SAASA,GACbA,CAACA;CACHA","file":"bundle.js","sourcesContent":["// # Bundle function\n// Takes a root decorated class and generates a Module from it\n\n// ## Setup\n// All information about traversing a provider is written by the appWriter\nimport {bundleStore} from './writers';\n// The bundle is going to be generating a Module, so we'll need this\nimport Module, {DecoratedModule} from './classes/module';\n// Events is a utility for generating semi-dynamic events. It will be generating\n// a lot of attribute directives for event handling.\nimport events from './events/events';\n// Takes an array of bindings and separates it into decorated classes and string\n// names. Usually these string names are the names of angular modules.\nimport groupModulesAndProviders from './util/group-modules-providers';\n\n// ## Bundle\n// The bundle function. Pass it the name of the module you want to generate, the root\n// provider, and an option list of additional bindings the provider may need to\n// successfully bootstrap. The idea is that you only need to provide bindings if you\n// are testing a component or service in isolation\nexport default function bundle(moduleName: string, provider: any, otherProviders: any[] = []):DecoratedModule {\n  // Get a list of decorated classes that some decorated class `t` depends on\n  const getProvidersFrom = (t: any) => bundleStore.get('providers', t) || [];\n  // Get a list of `angular.module` names some decorated class `t` depends on\n  const getModulesFrom = (t: any) => bundleStore.get('modules', t) || [];\n  // Look in a Set of Providers to see if it contains one with a specific token\n  const setHasProviderWithToken = (_set: Set<any>, token: any) => [..._set].filter(p => token && p.token === token).length > 0;\n\n  // Kick the process off by getting the list of `angular.module`s and decorated\n  // classes the root provider requires\n  let {modules: startingModules, providers: startingProviders} = groupModulesAndProviders([provider, ...otherProviders],\n  `during bundle entry point for '${moduleName}' module`);\n\n  // This set will be used to hold providers as they are traversed.\n  // Since sets can only contain unique values, we'll use this set to see if the provider\n  // has already been traversed. This will prevent circular references and providers\n  // being added multiple times.\n  let providers = new Set<any>();\n  // Create a new set of `angular.module`s based on the modules required by the\n  // root provider\n  let modules = new Set<ng.IModule>(startingModules);\n\n  // Recursive parsing function. Takes a provider and adds modules to the modules\n  // set. Then traverses the providers it depends on.\n  function parseProvider(provider: any){\n    if (provider) {\n      // Check to see if the provider is defined and hasn't been traversed already\n      // todo: do a better check of both token and value, figure out if we want to overwrite or discard duplicate\n      if (providers.has(provider) || setHasProviderWithToken(providers, provider.token)) {\n        return;\n      }\n\n      // Add the provider to the providers set\n      providers.add(provider);\n\n      // Get a reference to the useClass provider's annotated class, or the raw annotated class\n      let annotated = provider.useClass || provider.useFactory || provider;\n      // Add the annotated class' modules to the modules set\n      getModulesFrom(annotated).forEach((mod: any) => modules.add(mod));\n      // Parse the annotated class' inner providers\n      getProvidersFrom(annotated).forEach(parseProvider);\n    }\n  }\n\n  // Take the array of starting providers and begin the traversal\n  startingProviders.forEach(parseProvider);\n\n  // Create our Module and add all of the providers we found during traversal\n  return Module(moduleName, [...modules]).add(\n    ...events.resolve(),\n    ...providers\n  );\n}\n"],"sourceRoot":"/source/"}
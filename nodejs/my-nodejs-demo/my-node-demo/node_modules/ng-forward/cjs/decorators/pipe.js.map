{"version":3,"sources":["/source/decorators/lib/decorators/pipe.ts"],"names":[],"mappings":";;;;;;;;;;;6BAuBmB,mBAAmB;;;;oCAGT,2BAA2B;;;;AAKxD,IAAM,IAAI,GAAG,MAAM,CAAC;AAKpB,IAAa,IAAI,GAAiB,uCAAiB,IAAI,CAAC,CAAC;;AAGzD,2BAAO,WAAW,CAAC,IAAI,EAAE,UAAC,QAAa,EAAE,IAAY,EAAE,OAAiB,EAAE,QAAoB,EAAA;AAE7F,YAAQ,CAAC,MAAM,CAAC,IAAI,+BAAM,OAAO,IAAE,YAAuB;0CAAnB,YAAmB;AAAnB,wBAAmB;;;AAEzD,YAAI,IAAI,oBAAY,QAAQ,gBAAI,YAAY,KAAC,CAAC;AAI9C,YAAG,CAAC,IAAI,CAAC,SAAS,EAAC;AAClB,kBAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;SAC7D;AAGD,eAAO,UAAC,KAAU,EAAkB;+CAAb,MAAa;AAAb,sBAAa;;;AAGnC,gBAAG,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAC;AACzC,sBAAM,IAAI,KAAK,aAAW,IAAI,0BAAqB,KAAK,CAAG,CAAC;aAC5D;AAGD,mBAAO,IAAI,CAAC,SAAS,MAAA,CAAd,IAAI,GAAW,KAAK,SAAK,MAAM,EAAC,CAAC;SACxC,CAAA;KACD,GAAE,CAAC;CACJ,CAAC,CAAC","file":"decorators/pipe.js","sourcesContent":["// # Pipe Decorator\n// While not even close to a complete polyfill of Angular 2 pipes, for pure\n// filter functions you can begin writing them using pipe-like syntax.\n//\n// ## Usage\n// ```js\n// @Pipe('toUpperCase')\n// class ToUpperCase{\n// \tsupports(input){\n// \t\treturn typeof input === 'string';\n// \t}\n//\n// \ttransform(input){\n// \t\treturn input.toUpperCase();\n// \t}\n// }\n// ```\n// And in your templates:\n// ```html\n// {{ vm.name | toUpperCase }}\n// ```\n// ## Setup\n// This is a provider-type decorator, so we'll need to register it with Module\nimport Module from '../classes/module';\n// The only configurable information it needs is an optional name, so we'll\n// generate the decorator with our decorator factory.\nimport decoratorFactory from '../util/decorator-factory';\n\n// ## Decorator Definition\n// Provider type for for this decorator is `pipe`, though it is most analogous\n// to an Angular 1 filter.\nconst TYPE = 'pipe';\n\n// The decorator itself. Note that while the name is technically optional,\n// with pipes you will almost _always_ wants to provide a name to use in your\n// templates that is different from the class name. This keeps your code uglify-proof.\nexport const Pipe: (any) => any = decoratorFactory(TYPE);\n\n// ## Provider Parser\nModule.addProvider(TYPE, (provider: any, name: string, injects: string[], ngModule: ng.IModule) => {\n\t// This provider recipe uses Angular 1 filters\n\tngModule.filter(name, [...injects, (...dependencies: any[]) => {\n\t\t// First, create an instance of the provider by passing in injected dependencies\n\t\tlet pipe: any = new provider(...dependencies);\n\n\t\t// All pipes must implement a `transform` method. These __must__ be pure\n\t\t// functions (for some input, it must always return the same output)\n\t\tif(!pipe.transform){\n\t\t\tthrow new Error('Filters must implement a transform method');\n\t\t}\n\n\t\t// This is the Angular 1 filter itself\n\t\treturn (input: any, ...params: any[]) => {\n\t\t\t// Pass the input to the pipe to see if it conforms to the pipe's type\n\t\t\t// spec\n\t\t\tif(pipe.supports && !pipe.supports(input)){\n\t\t\t\tthrow new Error(`Filter ${name} does not support ${input}`);\n\t\t\t}\n\n\t\t\t// Pass all inputs and parameters to the filter returning the output\n\t\t\treturn pipe.transform(input, ...params);\n\t\t}\n\t}]);\n});\n"],"sourceRoot":"/source/"}
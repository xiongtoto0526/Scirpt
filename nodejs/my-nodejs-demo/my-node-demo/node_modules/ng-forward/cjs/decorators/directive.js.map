{"version":3,"sources":["/source/decorators/lib/decorators/directive.ts"],"names":["Directive"],"mappings":";;;;;;;;;;;iCAQ0B,wBAAwB;;;;uBAGN,YAAY;;yBAGhC,aAAa;;6BAElB,mBAAmB;;;;uCACC,8BAA8B;;;;2BAE9B,iBAAiB;;AAKxD,IAAM,IAAI,GAAG,WAAW,CAAC;;AAGzB,SAAA,SAAA,CACE,IAOC,EAAA;QANA,QAAQ,GADT,IAOC,CANA,QAAQ;yBADT,IAOC,CALA,SAAS;QAAT,SAAS,kCAAG,EAAE;;AAOhBA,WAAOA,UAASA,CAAMA,EAAAA;AAErB,YAAI,CAAC,QAAS,EAAE;AACf,kBAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;SACvD;;6BAG4B,oCAAc,QAAQ,CAAC;;YAA/C,IAAI,kBAAJ,IAAI;YAAQ,QAAQ,kBAAd,IAAI;;AAEf,YAAG,SAAS,KAAK,SAAS,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAC;AACvD,kBAAM,IAAI,SAAS,wCAAwC,CAAC;SAC5D;AAGD,+BAAc,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACnC,+BAAc,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AAInC,iEAAa,SAAS,EAAC,CAAC,CAAC,mCAAgC,CAAC,CAAC,IAAI,kBAAc,CAAC;AAG9E,gCAAe,GAAG,CAAC,UAAU,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;KAC5C,CAAAA;CACDA;;AAGD,2BAAO,WAAW,CAAC,IAAI,EAAE,UAAC,MAAW,EAAE,IAAY,EAAE,OAAiB,EAAE,QAAoB,EAAA;AAE3F,QAAI,GAAG,GAAQ,EAAE,CAAC;AAGlB,4BAAe,OAAO,CAAC,UAAC,GAAG,EAAE,GAAG;eAAK,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG;KAAA,EAAE,MAAM,CAAC,CAAC;AAI7D,QAAG,GAAG,CAAC,QAAQ,KAAK,GAAG,EAAE;AACxB,cAAM,IAAI,KAAK,CAAC,2CAAyB,MAAM,EAAE,QAAQ,mFACwB,CAAC,CAAC;KACnF;AAGD,YAAQ,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,UAAC,SAAmC,EAAA;AAG1E,WAAG,CAAC,IAAI,GAAG,UAAS,MAAW,EAAE,QAAa,EAAE,MAAW,EAAE,SAAc,EAAE,WAAgB,EAAA;AAC5F,gBAAI,MAAM,GAAG,EAAE,MAAM,EAAN,MAAM,EAAE,QAAQ,EAAR,QAAQ,EAAE,MAAM,EAAN,MAAM,EAAE,WAAW,EAAX,WAAW,EAAE,SAAS,EAAT,SAAS,EAAE,CAAC;AAClE,mBAAO,0CAA2B,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;SACjF,CAAC;AAEF,eAAO,GAAG,CAAC;KACX,CAAC,CAAC,CAAC;CACJ,CAAC,CAAC","file":"decorators/directive.js","sourcesContent":["// # Directive Decorator\n//\n// ## Usage\n//\n// ## Setup\n// `parseSelector` takes some simple CSS selector and returns a camelCased version\n// of the selector as well as the type of selector it was (element, attribute, or\n// CSS class).\nimport parseSelector from '../util/parse-selector';\n// `providerStore` sets up provider information, `componentStore` writes the DDO,\n// and `appWriter` sets up app traversal/bootstrapping information.\nimport {providerStore, componentStore} from '../writers';\n// Takes the information from `config.providers` and turns it into the actual metadata\n// needed during app traversal\nimport {Providers} from './providers';\n// Provider parser will need to be registered with Module\nimport Module from '../classes/module';\nimport directiveControllerFactory from '../util/directive-controller';\nimport {inputsMap} from '../properties/inputs-builder';\nimport {createConfigErrorMessage} from '../util/helpers';\n\n// The type for right now is `directive`. In angular-decorators there was very little\n// difference between `@Component` and `@Directive` so they shared a common provider\n// parser defined in `../../util/decorate-directive.js`\nconst TYPE = 'directive';\n\n// ## Decorator Definition\nexport function Directive(\n\t\t{\n\t\t\tselector,\n\t\t\tproviders = []\n\t\t} :\n\t\t{\n\t\t\tselector: string,\n\t\t\tproviders?: any[]\n\t\t}\n\t){\n\treturn function(t: any){\n\t\t// The only required config is a selector. If one wasn't passed, throw immediately\n\t\tif( !selector ) {\n\t\t\tthrow new Error('Directive selector must be provided');\n\t\t}\n\t\n\t\t// Grab the provider name and selector type by parsing the selector\n\t\tlet {name, type: restrict} = parseSelector(selector);\n\t\n\t\tif(providers !== undefined && !Array.isArray(providers)){\n\t\t\tthrow new TypeError(`Directive providers must be an array`);\n\t\t}\n\t\n\t\t// Setup provider information using the parsed selector\n\t\tproviderStore.set('name', name, t);\n\t\tproviderStore.set('type', TYPE, t);\n\t\n\t\t// Grab the providers from the config object, parse them, and write the metadata\n\t\t// to the target.\n\t\tProviders(...providers)(t, `while analyzing Directive '${t.name}' providers`);\n\t\n\t\t// Restrict type must be 'element'\n\t\tcomponentStore.set('restrict', restrict, t);\n\t}\n}\n\n// ## Component Provider Parser\nModule.addProvider(TYPE, (target: any, name: string, injects: string[], ngModule: ng.IModule) => {\n\t// First create an empty object to contain the directive definition object\n\tlet ddo: any = {};\n\n\t// Loop through the key/val pairs of metadata and assign it to the DDO\n\tcomponentStore.forEach((val, key) => ddo[key] = val, target);\n\n\t// If the selector type was not an element, throw an error. Components can only\n\t// be elements in Angular 2, so we want to enforce that strictly here.\n\tif(ddo.restrict !== 'A') {\n\t\tthrow new Error(createConfigErrorMessage(target, ngModule,\n\t\t\t\t`@Directive selectors can only be attributes, e.g. selector: '[my-directive]'`));\n\t}\n\n\t// Finally add the directive to the raw module\n\tngModule.directive(name, ['$injector', ($injector: ng.auto.IInjectorService) => {\n\t\t// Component controllers must be created from a factory. Checkout out\n\t\t// util/directive-controller.js for more information about what's going on here\n\t\tddo.link = function($scope: any, $element: any, $attrs: any, $requires: any, $transclude: any){\n\t\t\tlet locals = { $scope, $element, $attrs, $transclude, $requires };\n\t\t\treturn directiveControllerFactory(this, injects, target, ddo, $injector, locals);\n\t\t};\n\n\t\treturn ddo;\n\t}]);\n});\n"],"sourceRoot":"/source/"}
{"version":3,"sources":["/source/decorators/lib/decorators/state-config.ts"],"names":["StateConfig","targetIsStaticFn","Resolve","stateController"],"mappings":"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","file":"decorators/state-config.js","sourcesContent":["import {componentStore, bundleStore, providerStore} from '../writers';\nimport Module from '../classes/module';\nimport {Providers} from './providers';\nimport {componentHooks} from \"./component\";\nimport {createConfigErrorMessage} from '../util/helpers';\nimport {getInjectableName} from '../util/get-injectable-name';\nimport IState = ng.ui.IState;\nimport IStateProvider = ng.ui.IStateProvider;\n\nconst configsKey = 'ui-router.stateConfigs';\nconst childConfigsKey = 'ui-router.stateChildConfigs';\nconst annotatedResolvesKey = 'ui-router.annotatedResolves';\nconst resolvedMapKey = 'ui-router.resolvedMap';\n\nexport interface IComponentState extends IState {\n    component: any;\n}\n\n/**\n *\n * @param stateConfigs an array of state config objects\n * @example\n *\n * // Assume we also had two other components: Inbox and Compose\n *\n * @Component({ selector: 'app', template: '<ui-view></ui-view>' })\n * @StateConfig([\n *   { name: 'inbox', url: '/', component: Inbox, resolve: ... },\n *   { name: 'compose', url: '/compose', component: Compose }\n * ])\n * class App {}\n */\nexport function StateConfig(stateConfigs: IComponentState[]){\n    return function(t: any){\n        // Add all routed components as providers to this parent component so they are included in the bundle\n        Providers(...stateConfigs.map(sc => sc.component))(t, `while analyzing StateConfig '${t.name}' state components`);\n\n        // Store the state configs in the parent component's metadata...\n        componentStore.set(childConfigsKey, stateConfigs, t);\n\n        // ...But also store each child's own config in that child component's metadata\n        // currently not used, but might be useful in the future.\n        stateConfigs.forEach(config => {\n            if (!config.component) return;\n            let existingConfigs = componentStore.get(configsKey, config.component) || [];\n            componentStore.set(configsKey, [...existingConfigs, config], config.component);\n        });\n    }\n}\n\nfunction targetIsStaticFn(t) {\n    return t.name !== undefined && t.constructor.name === 'Function';\n}\n\n\n/**\n *\n * @param resolveName if you'd like to rename the resolve, otherwise it will use the name of the static method\n * @example\n *\n * @Component({ selector: 'inbox', template: '...' })\n * // Don't forget to also inject your resolve into your constructor with another @Inject up here, use a string for resolves.\n * @Inject('messages')\n * class Inbox {\n *\n *   // The resolve function must be static. You can optionally inject with @Inject\n *   @Resolve()\n *   @Inject('$http')\n *   static messages($http) {\n *      return $http.get('/api/messages);\n *   }\n *\n *   constructor(public messages) { }\n * }\n *\n * @Component({ selector: 'app', template: '<ui-view></ui-view>' })\n * @StateConfig([\n *   { name: 'inbox', url: '/', component: Inbox. }\n * ])\n * class App {}\n */\nexport function Resolve(resolveName: string = null){\n    return function(target: any, resolveFnName: string, {value: resolveFn}){\n        if (!targetIsStaticFn(target)) {\n            throw new Error('@Resolve target must be a static method.');\n        }\n\n        componentStore.merge(annotatedResolvesKey, {[resolveName || resolveFnName]: resolveFn}, target);\n    }\n}\n\ncomponentHooks.extendDDO((ddo: any) => {\n    if (ddo.template && ddo.template.replace) {\n        // Just a little sugar... so folks can write 'ng-outlet' if they want\n        ddo.template = ddo.template.replace(/ng-outlet/g, 'ui-view');\n    }\n});\n\ncomponentHooks.after((target: any, name: string, injects: string[], ngModule: ng.IModule) => {\n    const childStateConfigs: IComponentState[] = componentStore.get(childConfigsKey, target);\n\n    if (childStateConfigs) {\n        if (!Array.isArray(childStateConfigs)) {\n            throw new TypeError(createConfigErrorMessage(target, ngModule, '@StateConfig param must be an array of state objects.'));\n        }\n\n        ngModule.config(['$stateProvider', function($stateProvider: IStateProvider) {\n            if (!$stateProvider) return;\n\n            childStateConfigs.forEach((config: IComponentState) => {\n                // Grab tag name from component, use it to build a minimal state template\n                const tagName = bundleStore.get('selector', config.component);\n                config.template = config.template || `<${tagName}></${tagName}>`;\n\n                // You can add resolves in two ways: a 'resolve' property on the StateConfig, or via\n                // the @Resolve decorator. These lines handle merging of the two (@Resolve takes precedence)\n                // Also if a resolve function needs to be injected with @Inject we make sure to add $inject\n                // to that function so it works.\n                const annotatedResolves = componentStore.get(annotatedResolvesKey, config.component) || {};\n                Object.keys(annotatedResolves).forEach(resolveName => {\n                    const resolveFn = annotatedResolves[resolveName];\n                    const fnInjects = bundleStore.get('$inject', resolveFn);\n                    resolveFn.$inject = fnInjects;\n                });\n                config.resolve = Object.assign({}, config.resolve, annotatedResolves);\n\n                // Now grab all the @Inject-eds on the state component, map those injectables to\n                // their injectable names (in case they aren't strings). Construct a state controller\n                // that asks for those injected items. If any of them are resolves that will give us\n                // the fully resolved values of those resolves. We create a map of the resolved values\n                // and write the map as metadata on the state component. The map is then used below in\n                // the beforeCtrlInvoke hook to add the resolved values as locals to our component's\n                // constructor.\n                const childInjects = bundleStore.get('$inject', config.component);\n                const injects = childInjects ? childInjects.map(getInjectableName) : [];\n                function stateController(...resolves): any {\n                    const resolvedMap = resolves.reduce((obj, val, i) => {\n                        obj[injects[i]] = val;\n                        return obj;\n                    }, {});\n                    componentStore.set(resolvedMapKey, resolvedMap, config.component);\n                }\n                config.controller = config.controller || [...injects, stateController];\n\n                // Now actually add the state to $stateProvider\n                $stateProvider.state(config.name, config);\n            });\n        }]);\n    }\n});\n\ncomponentHooks.beforeCtrlInvoke((caller: any, injects: string[], controller: any, ddo: any, $injector: any, locals: any) => {\n    // Here we just grab the already resolved values and add them as locals before the component's\n    // controller is invoked\n    const resolvesMap = componentStore.get(resolvedMapKey, controller);\n    Object.assign(locals, resolvesMap);\n});\n\n\n"],"sourceRoot":"/source/"}